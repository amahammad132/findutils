// Copyright 2017 Google Inc.
//
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

use walkdir::DirEntry;

use super::{Matcher, MatcherIO};

use lscolors::{LsColors, Style};

use std::fmt::Write;

pub enum PrintDelimiter {
    Newline,
    Null,
}

impl std::fmt::Display for PrintDelimiter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PrintDelimiter::Newline => writeln!(f),
            PrintDelimiter::Null => write!(f, "\0"),
        }
    }
}

/// This matcher just prints the name of the file to stdout.
pub struct Printer {
    delimiter: PrintDelimiter,
}

impl Printer {
    pub fn new(delimiter: PrintDelimiter) -> Self {
        Self { delimiter }
    }
}

impl Matcher for Printer {
    // fn matches(&self, file_info: &DirEntry, matcher_io: &mut MatcherIO) -> bool {
    //     let mut out = matcher_io.deps.get_output().borrow_mut();
    //     let path = file_info.path();

    //     let lscolors = LsColors::from_env().unwrap_or_default();

    //     for (component, style) in lscolors.style_for_path_components(path) {
    //         let ansi_style = style.map(Style::to_ansi_term_style).unwrap_or_default();
    //         write!(out, "{}", ansi_style.paint(component.to_string_lossy())).unwrap();
    //     }

    //     write!(
    //         out,
    //         "{}",
    //         self.delimiter
    //     )
    //     .unwrap();
    //     out.flush().unwrap();
    //     true
    // }
    
    // IMPORTANT
    // this code works the best right now
    // fn matches(&self, file_info: &DirEntry, matcher_io: &mut MatcherIO) -> bool {
    //     let mut out = matcher_io.deps.get_output().borrow_mut();
    //     let path = file_info.path();

    //     let lscolors = LsColors::from_env().unwrap_or_default();
    //     let mut colored_path = String::new();

    //     for (component, style) in lscolors.style_for_path_components(path) {
    //         let ansi_style = style.map(Style::to_ansi_term_style).unwrap_or_default();
    //         write!(&mut colored_path, "{}", ansi_style.paint(component.to_string_lossy())).unwrap();
    //     }

    //     write!(
    //         out,
    //         "{}{}",
    //         colored_path,
    //         self.delimiter
    //     )
    //     .unwrap();
    //     out.flush().unwrap();
    //     true
    // }

    fn matches(&self, file_info: &DirEntry, matcher_io: &mut MatcherIO) -> bool {
        let mut out = matcher_io.deps.get_output().borrow_mut();
        let path = file_info.path();

        let lscolors = LsColors::from_env().unwrap_or_default();
        let mut colored_path = String::new();

        for (component, style) in lscolors.style_for_path_components(path) {
            let ansi_style = style.map(Style::to_ansi_term_style).unwrap_or_default();
            write!(&mut colored_path, "{}", ansi_style.paint(component.to_string_lossy())).unwrap();
        }

        write!(
            out,
            "{}{}",
            colored_path,
            self.delimiter
        )
        .unwrap();
        out.flush().unwrap();
        true
    }

//     fn matches(&self, file_info: &DirEntry, matcher_io: &mut MatcherIO) -> bool {
//         let mut out = matcher_io.deps.get_output().borrow_mut();
//         // let file_path = file_info.path().to_string_lossy();

//         // writeln!(out, "\x1b[93mError\x1b[0m").unwrap();
//         let lscolors = LsColors::from_env().unwrap_or_default();

//         // let style = lscolors.style_for_path(file_path);

//         // If you want to use `ansi_term`:
//         // let ansi_style = style.map(Style::to_ansi_term_style)
//         //               .unwrap_or_default();
//         // let colored_path = ansi_style.paint(file_path);
//         // let colored_path = style.paint(file_path);
//         // let style = Style::new().bold().on(Colour::Black);
        
//         // let meta = &file_info.metadata();
//         // let s = lscolors.style_for_path_with_metadata(file_info.path(), meta.ok());
//         // let s = lscolors.style_for_path_with_metadata(file_info.path(), meta.ok());
//         // let s = lscolors.style_for_path(file_info.path()).unwrap();
//         // let s = lscolors.style_for_path(file_info.path());
//         // let colored_path = (*s).paint(file_info.path().to_string_lossy());
//         // let colored_path = format!("{s:?}");

//         let s = lscolors.style_for_path(file_info.path());
//         let ansi_style = s.map(Style::to_ansi_term_style)
//                       .unwrap_or_default();
// // println!("{}", ansi_style.paint(path));
//         write!(
//             out,
//             "{}{}",
//             // "\x1b[93m{}{}\x1b[0m",
//             // file_path,
//             // colored_path,
//             ansi_style.paint(file_info.path().to_string_lossy()),
//             self.delimiter
//         )
//         .unwrap();
//         out.flush().unwrap();
//         true
//     }
    // fn matches(&self, file_info: &DirEntry, matcher_io: &mut MatcherIO) -> bool {
    //     let mut out = matcher_io.deps.get_output().borrow_mut();
    //     write!(
    //         out,
    //         "{}{}",
    //         file_info.path().to_string_lossy(),
    //         self.delimiter
    //     )
    //     .unwrap();
    //     out.flush().unwrap();
    //     true
    // }

    fn has_side_effects(&self) -> bool {
        true
    }
}

#[cfg(test)]

mod tests {
    use super::*;
    use crate::find::matchers::tests::get_dir_entry_for;
    use crate::find::matchers::Matcher;
    use crate::find::tests::fix_up_slashes;
    use crate::find::tests::FakeDependencies;

    #[test]
    fn prints_newline() {
        let abbbc = get_dir_entry_for("./test_data/simple", "abbbc");

        let matcher = Printer::new(PrintDelimiter::Newline);
        let deps = FakeDependencies::new();
        assert!(matcher.matches(&abbbc, &mut deps.new_matcher_io()));
        assert_eq!(
            fix_up_slashes("./test_data/simple/abbbc\n"),
            deps.get_output_as_string()
        );
    }

    #[test]
    fn prints_null() {
        let abbbc = get_dir_entry_for("./test_data/simple", "abbbc");

        let matcher = Printer::new(PrintDelimiter::Null);
        let deps = FakeDependencies::new();
        assert!(matcher.matches(&abbbc, &mut deps.new_matcher_io()));
        assert_eq!(
            fix_up_slashes("./test_data/simple/abbbc\0"),
            deps.get_output_as_string()
        );
    }
}
